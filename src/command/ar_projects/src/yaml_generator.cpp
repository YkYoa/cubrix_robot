#include "ar_projects/yaml_generator.h"
#include "ar_projects/motion_types/move_joint.h"
#include "ar_projects/motion_types/delay_motion.h"
#include "ar_projects/motion_types/set_planner.h"
#include "ar_projects/motion_types/set_velocity.h"

#include <fstream>
#include <sstream>
#include <iomanip>

namespace ar_projects
{

std::string YamlGenerator::generate(const ProjectConfig& config)
{
  std::stringstream ss;
  
  // Project header
  ss << "# Generated by BehaviorTree Manager\n";
  ss << "project:\n";
  ss << "  name: \"" << config.name << "\"\n";
  if (!config.description.empty()) {
    ss << "  description: \"" << config.description << "\"\n";
  }
  ss << "\n";
  
  // Defaults
  ss << "defaults:\n";
  ss << "  velocity_scaling: " << std::fixed << std::setprecision(2) << config.velocity_scaling << "\n";
  ss << "  acceleration_scaling: " << std::fixed << std::setprecision(2) << config.acceleration_scaling << "\n";
  ss << "  pipeline: \"" << config.default_pipeline << "\"\n";
  ss << "  planner: \"" << config.default_planner << "\"\n";
  ss << "\n";
  
  // Waypoints
  if (!config.waypoints.empty()) {
    ss << "waypoints:\n";
    for (const auto& wp : config.waypoints) {
      ss << "  " << wp.first << ": [";
      for (size_t i = 0; i < wp.second.size(); ++i) {
        ss << std::fixed << std::setprecision(4) << wp.second[i];
        if (i < wp.second.size() - 1) ss << ", ";
      }
      ss << "]\n";
    }
    ss << "\n";
  }
  
  // Sequence
  ss << "sequence:\n";
  for (const auto& motion : config.motions) {
    std::string type = motion->getType();
    
    ss << "  - type: \"" << type << "\"\n";
    if (!motion->getName().empty()) {
      ss << "    name: \"" << motion->getName() << "\"\n";
    }
    
    // Type-specific parameters
    if (type == "move_joint") {
      auto move = std::dynamic_pointer_cast<MoveJoint>(motion);
      if (move) {
        if (!move->getWaypoint().empty()) {
          ss << "    waypoint: \"" << move->getWaypoint() << "\"\n";
        } else {
          ss << "    joints: [";
          const auto& joints = move->getJoints();
          for (size_t i = 0; i < joints.size(); ++i) {
            ss << std::fixed << std::setprecision(4) << joints[i];
            if (i < joints.size() - 1) ss << ", ";
          }
          ss << "]\n";
        }
      }
    } else if (type == "delay") {
      auto delay = std::dynamic_pointer_cast<DelayMotion>(motion);
      if (delay) {
        ss << "    duration_ms: " << delay->getDurationMs() << "\n";
      }
    } else if (type == "set_planner") {
      auto planner = std::dynamic_pointer_cast<SetPlannerMotion>(motion);
      if (planner) {
        ss << "    pipeline: \"" << planner->getPipeline() << "\"\n";
        ss << "    planner_id: \"" << planner->getPlannerId() << "\"\n";
      }
    } else if (type == "set_velocity") {
      auto vel = std::dynamic_pointer_cast<SetVelocityMotion>(motion);
      if (vel) {
        ss << "    factor: " << std::fixed << std::setprecision(2) << vel->getFactor() << "\n";
      }
    } else if (type == "set_acceleration") {
      auto acc = std::dynamic_pointer_cast<SetAccelerationMotion>(motion);
      if (acc) {
        ss << "    factor: " << std::fixed << std::setprecision(2) << acc->getFactor() << "\n";
      }
    }
  }
  
  return ss.str();
}

bool YamlGenerator::writeToFile(const ProjectConfig& config, const std::string& output_filepath)
{
  std::ofstream file(output_filepath);
  if (!file.is_open()) {
    error_ = "Failed to open file for writing: " + output_filepath;
    return false;
  }
  
  file << generate(config);
  file.close();
  return true;
}

}  // namespace ar_projects
